# Sn√≠mek Projektu: Mediathek

*Vygenerov√°no: 2025-11-24 18:17:57*

## 1. Souhrn Projektu

Jedn√° se o projekt **web_app_mediathek**, postaven√Ω na n√°sleduj√≠c√≠m technologick√©m stacku: **Next.js, React, TypeScript, Tailwind CSS, Prisma, NextAuth.js, YouTube.js (InnerTube), Google Gemini AI**.

## 2. Anal√Ωza Projektu (package.json)

### Dostupn√© Skripty

| P≈ô√≠kaz (`npm run ...`) | Popis |
| ---------------------- | ----- |
| `dev` | `next dev` |
| `build` | `dotenv -e .env.local -- prisma generate && dotenv -e .env.local -- prisma migrate deploy && next build` |
| `start` | `next start` |
| `lint` | `eslint` |
| `prisma:migrate` | `dotenv -e .env.local -- prisma migrate dev` |
| `prisma:studio` | `dotenv -e .env.local -- prisma studio` |
| `prisma:generate` | `dotenv -e .env.local -- prisma generate` |

### Kl√≠ƒçov√© Z√°vislosti

| Knihovna | Verze | √öƒçel |
| -------- | ----- | ---- |
| `next` | `16.0.1` | Full-stack React framework |
| `react` | `19.2.0` | Knihovna pro tvorbu UI |
| `prisma` | `^6.18.0` | ORM a n√°stroj pro datab√°zi |
| `@prisma/client` | `^6.18.0` | ORM a n√°stroj pro datab√°zi |
| `next-auth` | `^4.24.13` | Knihovna pro autentizaci |
| `bcrypt` | `^6.0.0` | Knihovna pro hashov√°n√≠ hesel |
| `react-youtube` | `^10.1.0` | Knihovna pro vlo≈æen√≠ YouTube p≈ôehr√°vaƒçe |
| `youtubei.js` | `^16.0.1` | YouTube API klient (InnerTube) - F√°ze 10 |
| `@google/generative-ai` | `^0.24.1` | Google Gemini AI SDK - F√°ze 11 |
| `he` | `^1.2.0` | HTML Entity Decoder (pro text titulk≈Ø) |
| `tailwindcss` | `^4` | Utility-first CSS framework |
| `typescript` | `^5` | Typov√Ω syst√©m pro JavaScript |
| `eslint` | `^9` | Linter pro kvalitu k√≥du |
| `dotenv` | `^17.2.3` | N/A |
| `react-dom` | `19.2.0` | N/A |
| `@tailwindcss/postcss` | `^4` | N/A |
| `@types/bcrypt` | `^6.0.0` | N/A |
| `@types/he` | `^1.2.3` | N/A |
| `@types/node` | `^20` | N/A |
| `@types/react` | `^19` | N/A |
| `@types/react-dom` | `^19` | N/A |
| `dotenv-cli` | `^11.0.0` | N/A |
| `eslint-config-next` | `16.0.1` | N/A |
| `ts-node` | `^10.9.2` | N/A |

## 3. Environment√°ln√≠ Promƒõnn√©

Byl nalezen soubor `.env`. Aplikace oƒçek√°v√° n√°sleduj√≠c√≠ promƒõnn√© (hodnoty jsou skryty):
```
DATABASE_URL
```

Byl nalezen soubor `.env.local`. Aplikace oƒçek√°v√° n√°sleduj√≠c√≠ promƒõnn√© (hodnoty jsou skryty):
```
DATABASE_URL
DATABASE_URL_UNPOOLED
NEON_PROJECT_ID
PGDATABASE
PGHOST
PGHOST_UNPOOLED
PGPASSWORD
PGUSER
POSTGRES_DATABASE
POSTGRES_HOST
POSTGRES_PASSWORD
POSTGRES_PRISMA_URL
POSTGRES_URL
POSTGRES_URL_NON_POOLING
POSTGRES_URL_NO_SSL
POSTGRES_USER
VERCEL_OIDC_TOKEN
NEXTAUTH_SECRET
GEMINI_API_KEY
```

## 4. Syst√©mov√© Prost≈ôed√≠

```
Node.js verze: v24.11.0
NPM verze:     11.6.1
Prisma verze:  ^6.18.0 (z package.json)
Git verze:     git version 2.47.3
Syst√©m:        Linux rpi5 6.12.47+rpt-rpi-2712 #1 SMP PREEMPT Debian 1:6.12.47-1+rpt1 (2025-09-16) aarch64 GNU/Linux
```

## 5. Stav Git Repozit√°≈ôe

```
On branch feature/faze-11-ai-content
M app/admin/add/page.tsx
 M app/admin/edit/[id]/page.tsx
 M archiv/README_10_02REALIZACE
 M package-lock.json
 M package.json
?? app/api/ai/
?? archiv/README_10_03project_snapshot
?? archiv/README_11_01ZADANI
?? archiv/README_11_02REALIZACE
```

## 6. Struktura Projektov√©ho Adres√°≈ôe

```
./
    1763586862976-player-script.js
    1763586489510-player-script.js
    1763587042519-player-script.js
    postcss.config.mjs
    middleware.ts
    1763586688369-player-script.js
    1763586489527-player-script.js
    README.md
    next-env.d.ts
    .gitignore
    project_snapshot.md
    1763586862960-player-script.js
    test-env.js
    1763586688358-player-script.js
    1763587042502-player-script.js
    next.config.ts
    prisma.config.ts
    package.json
    tsconfig.json
    eslint.config.mjs
    components/
        Navbar.tsx
        VideoDetailClientWrapper.tsx
        VideoGrid.tsx
        Providers.tsx
        DeleteButton.tsx
        VideoPlayer.tsx
        ChapterList.tsx
    prisma/
        schema.prisma
        migrations/
            migration_lock.toml
            20251112204337_add_chapter_model/
                migration.sql
            20251119175653_add_transcript_model/
                migration.sql
            20251116101540_add_collection_model/
                migration.sql
            20251102210418_init_user_model/
                migration.sql
            20251104201217_add_video_model/
                migration.sql
    .vercel/
        project.json
        README.txt
    app/
        favicon.ico
        layout.tsx
        page.tsx
        globals.css
        dashboard/
            page.tsx
        api/
            ai/
                generate/
                    route.ts
            auth/
                [...nextauth]/
                    route.ts
            videos/
                route.ts
                [id]/
                    route.ts
            youtube/
                fetch-data/
                    route.ts
            collections/
                route.ts
                [id]/
                    route.ts
            register/
                route.ts
        video/
            [id]/
                page.tsx
        admin/
            dashboard/
                page.tsx
            add/
                page.tsx
            collections/
                page.tsx
            manage/
                page.tsx
            edit/
                [id]/
                    page.tsx
        register/
            page.tsx
        login/
            page.tsx
    public/
        file.svg
        window.svg
        next.svg
        vercel.svg
        globe.svg
    lib/
        parser.ts
    types/
        next-auth.d.ts
```

## 7. Obsah Kl√≠ƒçov√Ωch Soubor≈Ø

### `package.json`

```json
{
  "name": "web_app_mediathek",
  "version": "0.1.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "dotenv -e .env.local -- prisma generate && dotenv -e .env.local -- prisma migrate deploy && next build",
    "start": "next start",
    "lint": "eslint",
    "prisma:migrate": "dotenv -e .env.local -- prisma migrate dev",
    "prisma:studio": "dotenv -e .env.local -- prisma studio",
    "prisma:generate": "dotenv -e .env.local -- prisma generate"
  },
  "dependencies": {
    "@google/generative-ai": "^0.24.1",
    "@prisma/client": "^6.18.0",
    "bcrypt": "^6.0.0",
    "dotenv": "^17.2.3",
    "he": "^1.2.0",
    "next": "16.0.1",
    "next-auth": "^4.24.13",
    "prisma": "^6.18.0",
    "react": "19.2.0",
    "react-dom": "19.2.0",
    "react-youtube": "^10.1.0",
    "youtubei.js": "^16.0.1"
  },
  "devDependencies": {
    "@tailwindcss/postcss": "^4",
    "@types/bcrypt": "^6.0.0",
    "@types/he": "^1.2.3",
    "@types/node": "^20",
    "@types/react": "^19",
    "@types/react-dom": "^19",
    "dotenv-cli": "^11.0.0",
    "eslint": "^9",
    "eslint-config-next": "16.0.1",
    "tailwindcss": "^4",
    "ts-node": "^10.9.2",
    "typescript": "^5"
  }
}

```

### `middleware.ts`

```typescript
    import { withAuth } from 'next-auth/middleware';
    import { NextResponse } from 'next/server';
    
    export default withAuth(
      // `middleware` se vol√° POUZE pokud je token platn√Ω (u≈æivatel p≈ôihl√°≈°en)
      function middleware(req) {
        const token = req.nextauth.token;
        const { pathname } = req.nextUrl;
    
        // 1. Ochrana /admin
        if (pathname.startsWith('/admin')) {
          // Pokud je p≈ôihl√°≈°en, ale NEN√ç admin, p≈ôesmƒõruj pryƒç
          if (token?.role !== 'ADMIN') {
            // M≈Ø≈æeme p≈ôesmƒõrovat na dashboard nebo domovskou str√°nku
            return NextResponse.redirect(new URL('/dashboard', req.url));
          }
        }
        
        // 2. Pro /dashboard staƒç√≠ b√Ωt p≈ôihl√°≈°en, co≈æ `withAuth` ji≈æ ≈ôe≈°√≠.
    
        // Pokud projde kontrolou role, pokraƒçuj
        return NextResponse.next();
      },
      {
        // Callback pro `withAuth`
        callbacks: {
          // Vol√° se V≈ΩDY, kdy≈æ se p≈ôistupuje na chr√°nƒõnou trasu v `matcher`u
          authorized: ({ token }) => {
            // Pokud u≈æivatel nem√° token (nen√≠ p≈ôihl√°≈°en),
            // `withAuth` ho automaticky p≈ôesmƒõruje na `signIn` str√°nku.
            return !!token; // !!token p≈ôevede token (nebo null) na boolean
          },
        },
        pages: {
          signIn: '/login', // Str√°nka pro p≈ôesmƒõrov√°n√≠ nep≈ôihl√°≈°en√Ωch
        },
      }
    );
    
    // Konfigurace matcheru (kter√© str√°nky chr√°nit)
    export const config = {
      matcher: [
        '/dashboard/:path*', // P≈Øvodn√≠ chr√°nƒõn√° trasa
        '/admin/:path*',    // Nov√° chr√°nƒõn√° trasa pro adminy
      ],
    };
```

### `prisma/schema.prisma`

```text
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Definice rol√≠ pro u≈æivatele
enum Role {
  USER
  ADMIN
}

// Datov√Ω model pro u≈æivatele
model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  role      Role     @default(USER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Vztah: U≈æivatel m≈Ø≈æe p≈ôidat v√≠ce vide√≠
  videos      Video[]
  // Sb√≠rky vytvo≈ôen√© u≈æivatelem
  collections Collection[]
}

model Video {
  id        String   @id @default(cuid())
  youtubeId String   @unique // ID videa z URL (nap≈ô. "dQw4w9WgXcQ")
  title     String   // Manu√°lnƒõ zadan√Ω n√°zev
  summary   String   @db.Text // Manu√°lnƒõ zadan√© shrnut√≠ (del≈°√≠ text)

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Propojen√≠ na autora
  authorId  String
  author    User     @relation(fields: [authorId], references: [id])

  chapters    Chapter[]
  // Relace M:N (Video m≈Ø≈æe b√Ωt ve v√≠ce sb√≠rk√°ch)
  collections Collection[]
  // Relace 1:1 na p≈ôepis
  transcript  Transcript?
}

model Chapter {
  id        String   @id @default(cuid())
  text      String   // Zobrazen√Ω text (nap≈ô. "1.1. √övod...")
  startTime Int      // ƒåas "od" v sekund√°ch
  endTime   Int?     // ƒåas "do" v sekund√°ch (nepovinn√©)
  level     Int      // √örove≈à zano≈ôen√≠ (0 = ko≈ôen, 1 = podkapitola)
  order     Int      // Po≈ôad√≠ kapitoly v r√°mci videa

  // Relace k videu. P≈ôi smaz√°n√≠ videa se sma≈æou i kapitoly.
  video   Video  @relation(fields: [videoId], references: [id], onDelete: Cascade)
  videoId String
}

// Model pro sb√≠rky vide√≠
model Collection {
  id          String   @id @default(cuid())
  name        String
  description String?  @db.Text
  isPublic    Boolean  @default(false) // P≈ô√≠znak viditelnosti
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Vlastnictv√≠ (RBAC)
  authorId    String
  author      User     @relation(fields: [authorId], references: [id])

  // Vztah M:N s videi
  videos      Video[]
}

// Model pro p≈ôepisy vide√≠
model Transcript {
  id          String   @id @default(cuid())
  
  // Relace 1:1 na Video
  videoId     String   @unique
  video       Video    @relation(fields: [videoId], references: [id], onDelete: Cascade)
  
  // Obsah
  content     String   @db.Text      // Surov√Ω text titulk≈Ø spojen√Ω do jednoho bloku
  fullData    Json?                  // Kompletn√≠ JSON s ƒçasov√Ωmi znaƒçkami (pro budouc√≠ AI)
  language    String   @default("cs") // Jazyk titulk≈Ø
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}
```

### `types/next-auth.d.ts`

```typescript
import 'next-auth';
import 'next-auth/jwt';

/**
 * Roz≈°i≈ôujeme standardn√≠ typy NextAuth, abychom TypeScriptu
 * ≈ôekli, ≈æe budeme do session a tokenu p≈ôid√°vat vlastn√≠ data.
 */

declare module 'next-auth' {
  /**
   * Toto je objekt, kter√Ω vid√≠ klient (nap≈ô. p≈ôes useSession())
   */
  interface Session {
    user: {
      id: string;
      role: string;
    } & DefaultSession['user']; // Zachov√°me i standardn√≠ vlastnosti (name, email, image)
  }

  /**
   * Toto je objekt 'user', kter√Ω vrac√≠me z providera (authorize)
   * a dost√°v√°me v JWT callbacku.
   */
  interface User {
    // V√Ωchoz√≠ User ji≈æ m√° id, name, email, image.
    // My p≈ôid√°v√°me pouze na≈°i roli.
    role: string;
  }
}

/**
 * Roz≈°√≠≈ôen√≠ JWT tokenu.
 */
declare module 'next-auth/jwt' {
  /** Toto je obsah na≈°eho JWT tokenu v cookie. */
  interface JWT {
    id: string;
    role: string;
  }
}

```

### `app/layout.tsx`

```typescript
import type { Metadata } from "next";
import { Geist, Geist_Mono } from "next/font/google";
import "./globals.css";
import Providers from "@/components/Providers";
import Navbar from "@/components/Navbar"; // <-- 1. Importujte Navbar

const geistSans = Geist({
  variable: "--font-geist-sans",
  subsets: ["latin"],
});

const geistMono = Geist_Mono({
  variable: "--font-geist-mono",
  subsets: ["latin"],
});

export const metadata: Metadata = {
  title: "Create Next App",
  description: "Generated by create next app",
};

export default function RootLayout({
  children,
}: Readonly<{
  children: React.ReactNode;
}>) {
  return (
    <html lang="en">
      <body
        className={`${geistSans.variable} ${geistMono.variable} antialiased`}
      >
        <Providers>
          <Navbar /> {/* <-- 2. Vlo≈æte Navbar sem (dovnit≈ô Providers) */}
          <main>{children}</main>
        </Providers>
      </body>
    </html>
  );
}
```

### `app/page.tsx`

```typescript
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { PrismaClient, Prisma } from '@prisma/client';
// 1. Importujeme na≈°i sd√≠lenou komponentu
import VideoGrid from '@/components/VideoGrid';

const prisma = new PrismaClient();

// Vynut√≠me dynamick√© renderov√°n√≠, aby se session v≈ædy ƒçetla ƒçerstv√°
export const dynamic = 'force-dynamic';

export default async function HomePage() {
  const session = await getServerSession(authOptions);

  // 2. Sestaven√≠ dynamick√©ho 'where' dotazu dle specifikace F√°ze 8
  
  // V√Ωchoz√≠ pravidlo: VISITOR a USER vid√≠ jen videa,
  // kter√° jsou v ALESPO≈á JEDN√â ve≈ôejn√© sb√≠rce.
  let whereClause: Prisma.VideoWhereInput = {
    collections: {
      some: {
        isPublic: true,
      },
    },
  };

  // V√Ωjimka: ADMIN vid√≠ V≈†ECHNO (drafty, soukrom√©, ve≈ôejn√©)
  if (session && session.user.role === 'ADMIN') {
    whereClause = {}; // Pr√°zdn√Ω 'where' znamen√° "v≈°e"
  }
  
  // TODO: Logika pro KURATORA (F√°ze 9)
  // if (session && session.user.role === 'KURATOR') {
  //   whereClause = {
  //     OR: [
  //       { collections: { some: { isPublic: true } } },
  // { authorId: session.user.id }
  //     ]
  //   };
  // }

  // 3. Fin√°ln√≠ dotaz do DB
  // AKTUALIZACE: P≈ôid√°me 'include' autora, aby VideoGrid
  // mohl zobrazit stejn√© detaily jako admin dashboard.
  const videos = await prisma.video.findMany({
    where: whereClause,
    orderBy: {
      createdAt: 'desc',
    },
    include: {
      author: {
        select: {
          email: true
        }
      },
      // P≈òID√ÅNO: Naƒçten√≠ n√°zv≈Ø a ID p≈ôi≈ôazen√Ωch sb√≠rek
      collections: {
        select: {
          id: true,
          name: true
        }
      }
    }
  });

  // 4. Zobrazen√≠ pomoc√≠ sd√≠len√© komponenty
  return (
    <main className="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
      <h1 className="text-3xl font-bold mb-8">V√≠tejte v Mediathek - zde je Va≈°e knihovna medi√°ln√≠ho obsahu - prohl√≠≈æejte sb√≠rky shlednut√Ωch vide√≠ vytvo≈ôen√Ωch jin√Ωmi nejen pro sebe, ale tak√© i pro V√°s - vytv√°≈ôejte t√©mata - uspo≈ô√°d√°vejte i svou sb√≠rku - vyb√≠rejte to nejlep≈°√≠ - dƒõlejte si pozn√°mky ke shlednut√©mu - sd√≠lejte svou sb√≠rku s ostatn√≠mi - dejte medi√°ln√≠mu obsahu sv≈Øj jedineƒçn√Ω pohled</h1>
      
      {/* AKTUALIZACE: Pou≈æijeme stejnou komponentu, ale zmƒõn√≠me
        baseHref, aby odkazy smƒõ≈ôovaly na budouc√≠
        ve≈ôejnou str√°nku detailu (nap≈ô. /video/[id]).
        Prozat√≠m m≈Ø≈æeme nechat /admin/video, 
        n√°v≈°tƒõvn√≠k bude p≈ôesmƒõrov√°n na /login (Test 5).
      */}
      <VideoGrid videos={videos} baseHref="/video" showEditButton={false} />
    </main>
  );
}
```

### `components/Navbar.tsx`

```typescript
"use client";

import Link from "next/link";
import { useSession } from "next-auth/react";

export default function Navbar() {
  const { data: session, status } = useSession();

  return (
    <nav style={{ display: "flex", gap: "1rem", padding: "1rem", background: "#eee" }}>
      <Link href="/">Dom≈Ø</Link>

      {status === "loading" && <p>...</p>}

      {status === "unauthenticated" && (
        <>
          <Link href="/login">P≈ôihl√°sit se</Link>
          <Link href="/register">Registrovat</Link>
        </>
      )}

      {status === "authenticated" && (
        <>
          <Link href="/dashboard">M≈Øj Dashboard</Link>
          
          {/* --- ADMIN NAVIGACE --- */}
          {session.user?.role === 'ADMIN' && (
            <>
              <Link href="/admin/dashboard" className="hover:underline">P≈ôehled obsahu</Link>
              <Link href="/admin/manage" className="hover:underline">Spr√°va obsahu</Link>
              <Link href="/admin/collections" className="hover:underline">Sb√≠rky</Link>
              <Link href="/admin/add" className="font-bold hover:underline">P≈ôidat video</Link>
            </>
          )}
          {/* --- KONEC ADMIN NAVIGACE --- */}

          <span style={{ marginLeft: "auto" }}>
            P≈ôihl√°≈°en: {session.user?.email}
          </span>
        </>
      )}
    </nav>
  );
}
```

### `components/VideoDetailClientWrapper.tsx`

```typescript
"use client";

import { useRef } from 'react';
import { Prisma } from '@prisma/client';
import VideoPlayer from '@/components/VideoPlayer';
import ChapterList from '@/components/ChapterList';

// P≈ôij√≠m√°me data naƒçten√° na serveru
type ChapterWithData = Prisma.ChapterGetPayload<{}>;

interface VideoDetailClientWrapperProps {
  youtubeId: string;
  chapters: ChapterWithData[];
  summary: string; // ZMƒöNA: Nyn√≠ p≈ôij√≠m√°me i summary
}

export default function VideoDetailClientWrapper({
  youtubeId,
  chapters,
  summary, // ZMƒöNA: Pou≈æ√≠v√°me summary
}: VideoDetailClientWrapperProps) {
  // Reference pro ovl√°d√°n√≠ p≈ôehr√°vaƒçe
  const playerRef = useRef(null);

  return (
    // [NASTAVENI GRID A POMERU SLOUPCU ZDE] Grid a pomƒõr sloupc≈Ø
    <div className="lg:grid lg:grid-cols-14 lg:gap-8">
      
      {/* --- LEV√ù SLOUPEC (Video a Shrnut√≠) --- */}
      {/* [NASTAVENI GRID A POMERU SLOUPCU ZDE] Lev√Ω sloupec - video */}
      <div className="lg:col-span-8">
        {/* P≈ôehr√°vaƒç Videa */}
        <div
          className="relative bg-black rounded-lg overflow-hidden"
          style={{ paddingTop: '56.25%' /* Pomƒõr 16:9 */ }}
        >
          <VideoPlayer
            youtubeId={youtubeId}
            onReady={(event) => (playerRef.current = event.target)}
          />
        </div>

        {/* Popis / Shrnut√≠ (P≈ôesunuto sem) */}
        <div className="mt-8">
          <h2 className="text-2xl font-semibold mb-4">Shrnut√≠</h2>
          {/* Pou≈æ√≠v√°me opraven√© t≈ô√≠dy pro barvu textu (z minul√© √∫pravy) */}
          <p className="text-gray-900 dark:text-gray-100 whitespace-pre-wrap text-lg">
            {summary}
          </p>
        </div>
      </div>

      {/* --- PRAV√ù SLOUPEC (Strukturovan√Ω Obsah) --- */}
      {/* [NASTAVENI GRID A POMERU SLOUPCU ZDE] Prav√Ω sloupec - obsah */}
      <div className="lg:col-span-6 mt-8 lg:mt-0">
        
        {/* Wrapper, kter√Ω zajist√≠ "p≈ôilepen√≠" (sticky) a scrollov√°n√≠ */}
        {/* 'lg:sticky' - p≈ôilep√≠ se na desktopu
            'lg:top-8' - odsazen√≠ 8px od vr≈°ku viewportu
            'lg:max-h-[90vh]' - maxim√°ln√≠ v√Ω≈°ka (90% v√Ω≈°ky okna)
            'lg:overflow-y-auto' - p≈ôid√° posuvn√≠k, pokud je obsah del≈°√≠
        */}
        <div className="lg:sticky lg:top-8 lg:max-h-[90vh] lg:overflow-y-auto rounded-lg">
          {/* Strukturovan√Ω Obsah */}
          <div>
            {/* Odebr√°no mt-8, ≈ôe≈°√≠ se vnƒõj≈°√≠m divem */}
            <h2 className="text-2xl font-semibold mb-4">Strukturovan√Ω obsah</h2>
            <ChapterList chapters={chapters} playerRef={playerRef} />
          </div>
        </div>
      </div>
    </div>
  );
}
```

### `components/VideoPlayer.tsx`

```typescript
"use client";

import YouTube from 'react-youtube';

interface VideoPlayerProps {
  youtubeId: string;
  // 1. P≈òID√ÅN√ç onReady PROPU
  onReady?: (event: { target: any }) => void;
}

export default function VideoPlayer({ youtubeId, onReady }: VideoPlayerProps) {
  const opts = {
    height: '100%',
    width: '100%',
    playerVars: {
      autoplay: 0,
    },
  };
  
  return (
    <YouTube
      videoId={youtubeId}
      opts={opts}
      className="absolute top-0 left-0 w-full h-full"
      // 2. PROPOJEN√ç onReady
      onReady={onReady}
    />
  );
}
```

### `components/ChapterList.tsx`

```typescript
"use client";

import { Prisma } from '@prisma/client';
import { RefObject } from 'react';

// Explicitnƒõ definujeme typ, kter√Ω oƒçek√°v√°me z Prisma dotazu
type ChapterWithData = Prisma.ChapterGetPayload<{}>;

interface ChapterListProps {
  chapters: ChapterWithData[];
  playerRef: RefObject<any>; // Reference na YouTube p≈ôehr√°vaƒç
}

export default function ChapterList({ chapters, playerRef }: ChapterListProps) {
  if (!chapters || chapters.length === 0) {
    return <p className="text-gray-900 dark:text-gray-100">Pro toto video nen√≠ dostupn√Ω strukturovan√Ω obsah.</p>;
  }

  const handleChapterClick = (startTime: number) => {
    playerRef.current?.seekTo(startTime); // Funkce pro skok v ƒçase
    playerRef.current?.playVideo(); // Voliteln√©: rovnou spustit p≈ôehr√°v√°n√≠
  };

  return (
    <div className="space-y-2">
      {chapters.map((chapter) => {
        return (
          <button
            key={chapter.id}
            onClick={() => handleChapterClick(chapter.startTime)}
            className="block w-full text-left p-3 rounded-md transition-colors 
                       text-gray-900 dark:text-gray-100 
                       hover:bg-gray-100 dark:hover:bg-gray-700"
            style={{
              // Hierarchick√© odsazen√≠ na z√°kladƒõ 'level' z DB
              marginLeft: `${chapter.level * 20}px`,
              width: `calc(100% - ${chapter.level * 20}px)`,
            }}
          >
            {/* Jednodu≈°e zobraz√≠me 'text' z datab√°ze - Zdroj Pravdy */}
            {chapter.text}
          </button>
        );
      })}
    </div>
  );
}
```

### `components/VideoGrid.tsx`

```typescript
// V souladu se zad√°n√≠m F√°ze 8 vytv√°≈ô√≠me klientskou komponentu
"use client";

import Link from 'next/link';
// Importujeme typy z Prisma
import { Video, User } from '@prisma/client';

// Typ pro data komponenty
type VideoWithDetails = Video & {
  author: { email: string | null } | null;
  collections: { id: string; name: string }[];
};

interface VideoGridProps {
  videos: VideoWithDetails[];
  baseHref?: string;
  showEditButton?: boolean;
}

// Komponenta pouze p≈ôij√≠m√° pole vide√≠ a vykresluje je
export default function VideoGrid({ videos, baseHref = '/admin/video', showEditButton }: VideoGridProps) {
  
  // Pokud nejsou ≈æ√°dn√° videa, zobraz√≠me zpr√°vu
  if (videos.length === 0) {
    return (
      <p className="text-center text-gray-400">
        Nebyly nalezeny ≈æ√°dn√© video z√°znamy.
      </p>
    );
  }

  // Vykreslen√≠ m≈ô√≠≈æky
  return (
    <div className="grid grid-cols-1 md:grid-cols-2 lg:grid-cols-3 gap-6">
      {videos.map((video) => (
        <Link
          href={`${baseHref}/${video.id}`}
          key={video.id}
          className="bg-white dark:bg-gray-800 border border-gray-200 dark:border-gray-700 rounded-lg shadow-sm overflow-hidden flex flex-col transition-all duration-200 hover:shadow-lg hover:ring-2 hover:ring-indigo-500"
        >
          {/* N√°hled videa z YouTube (Z√≥na 1 - ƒç√°st 1) */}
          <div className="aspect-video bg-gray-100 dark:bg-gray-700 relative">
             <img
                src={`https://img.youtube.com/vi/${video.youtubeId}/mqdefault.jpg`}
                alt={`N√°hled videa ${video.title}`}
                className="w-full h-full object-cover"
                loading="lazy"
             />
          </div>

          {/* Kontejner pro textov√Ω obsah (tƒõlo i z√°pat√≠) */}
          <div className="flex-1 flex flex-col">

            {/* Z√≥na 1 - ƒç√°st 2 (Tƒõlo - obsah z internetu) */}
            {/* P≈ôid√°n flex-1 pro lep≈°√≠ rozvr≈æen√≠ - z√°pat√≠ bude v≈ædy dole */}
            <div className="p-5 flex-1">
              <h2 className="text-xl font-semibold mb-2 line-clamp-2" title={video.title}>
                {video.title}
              </h2>

              <div className="text-sm text-gray-500 dark:text-gray-400 mb-4">
                  <p>ID: <span className="font-mono">{video.youtubeId}</span></p>
              </div>

              <p className="text-gray-600 dark:text-gray-300 line-clamp-3 mb-0">
                {video.summary}
              </p>
            </div>

            {/* Z√≥na 2 (Z√°pat√≠ - obsah aplikace) */}
            {/* Sn√≠≈æen√© odsazen√≠ (pt-2 pb-2) a mezery (space-y-1) pro kompaktnƒõj≈°√≠ vzhled */}
            <div className="mt-auto pt-2 pb-2 border-t border-gray-200 dark:border-gray-700 
                            text-xs space-y-1 
                            bg-violet-50 dark:bg-violet-900/30">
              
              {/* Sekce 1: Kur√°torsk√° metadata */}
              <div className="text-gray-600 dark:text-gray-300 space-y-1 px-5">
                <p>
                  <strong>Sb√≠rka(y):</strong> {
                    video.collections.length > 0 
                      ? video.collections.map(c => c.name).join(', ') 
                      : 'Neza≈ôazeno'
                  }
                </p>
                <p>
                  <strong>Kur√°tor:</strong> {video.author?.email || 'Nezn√°m√Ω'}
                </p>
              </div>

              {/* Sekce 2: Datum a Edit link */}
              <div className="flex justify-between items-center text-gray-500 dark:text-gray-400 px-5">
                <span>
                    {new Date(video.createdAt).toLocaleDateString('cs-CZ')}
                </span>
                {showEditButton === true && (
                     <Link href={`/admin/edit/${video.id}`} className="text-indigo-500 hover:text-indigo-700 font-medium transition-colors hover:text-indigo-400">
                        Upravit
                     </Link>
                )}
              </div>
            </div>
            {/* === KONEC Z√ÅPAT√ç === */}
          </div>
        </Link>
      ))}
    </div>
  );
}
```

### `app/admin/dashboard/page.tsx`

```typescript
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth';
import { redirect } from 'next/navigation';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import Link from 'next/link';
// 1. Importujeme na≈°i novou sd√≠lenou komponentu
import VideoGrid from '@/components/VideoGrid';

const prisma = new PrismaClient();

export const dynamic = 'force-dynamic';

export default async function AdminDashboardPage() {
  // 1. Bezpeƒçnostn√≠ kontrola na serveru (z≈Øst√°v√°)
  const session = await getServerSession(authOptions);

  if (!session || session.user?.role !== 'ADMIN') {
    redirect('/');
  }

  // 2. Naƒçten√≠ dat z datab√°ze
  // AKTUALIZACE: Ponech√°v√°me naƒç√≠t√°n√≠ autora, jak je ve va≈°em souboru.
  // To je d≈Øle≈æit√© pro VideoGrid.
  const videos = await prisma.video.findMany({
    orderBy: {
      createdAt: 'desc',
    },
    include: {
      author: {
        select: {
            email: true
        }
      },
      // P≈òID√ÅNO: Naƒçten√≠ n√°zv≈Ø a ID p≈ôi≈ôazen√Ωch sb√≠rek
      collections: {
        select: {
          id: true,
          name: true
        }
      }
    }
  });

  // 3. Vykreslen√≠ UI
  return (
    <main className="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">P≈ôehled Obsahu (Admin Dashboard)</h1>
        <Link
          href="/admin/add"
          className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors"
        >
          + P≈ôidat nov√© video
        </Link>
      </div>

      {/* AKTUALIZACE: Cel√Ω p≈Øvodn√≠ blok (<div className="grid...">...</div>) 
        je nyn√≠ nahrazen touto jedinou komponentou.
      */}
      <VideoGrid videos={videos} baseHref="/video" showEditButton={true} />
      
    </main>
  );
}
```

### `app/admin/manage/page.tsx`

```typescript
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth';
import { redirect } from 'next/navigation';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import Link from 'next/link';
import DeleteButton from '@/components/DeleteButton'; // Importujeme novou komponentu

const prisma = new PrismaClient();

// Zajist√≠, ≈æe se str√°nka p≈ôi ka≈æd√©m naƒçten√≠ p≈ôegeneruje (dynamick√©)
export const dynamic = 'force-dynamic'; 

export default async function AdminManagePage() {
  const session = await getServerSession(authOptions);

  // Ochrana str√°nky
  if (!session || session.user?.role !== 'ADMIN') {
    redirect('/');
  }

  // Naƒç√≠t√°n√≠ dat na z√°kladƒõ role (p≈ô√≠prava na budouc√≠ roli KURATOR)
  // OPRAVA CHYBY: Mus√≠me sestavit argumenty a zavolat findMany jen jednou.
     
  // 1. Definujeme 'where' podm√≠nku na z√°kladƒõ role
  const whereCondition = 
    session.user.role === 'ADMIN' 
    ? {} // Admin vid√≠ v≈°e (pr√°zdn√° podm√≠nka)
    : { authorId: session.user.id }; // Ostatn√≠ jen sv√©

  // 2. Zavol√°me findMany POUZE JEDNOU s fin√°ln√≠mi argumenty
  const videos = await prisma.video.findMany({
    where: whereCondition, // Aplikujeme podm√≠nku
    orderBy: {
      createdAt: 'desc',
    },
    select: {
      id: true,
      title: true,
      createdAt: true,
      updatedAt: true,
    },
  });

  return (
    <main className="max-w-7xl mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex justify-between items-center mb-8">
        <h1 className="text-3xl font-bold">Spr√°va Obsahu</h1>
        <Link
          href="/admin/add"
          className="bg-indigo-600 hover:bg-indigo-700 text-white font-bold py-2 px-4 rounded transition-colors"
        >
          + P≈ôidat nov√© video
        </Link>
      </div>

      <div className="bg-white dark:bg-gray-800 shadow-md rounded-lg overflow-hidden">
        <table className="min-w-full divide-y divide-gray-200 dark:divide-gray-700">
          <thead className="bg-gray-50 dark:bg-gray-700">
            <tr>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                N√°zev
              </th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                Datum p≈ôid√°n√≠
              </th>
              <th scope="col" className="px-6 py-3 text-left text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                Posl. √∫prava
              </th>
              <th scope="col" className="px-6 py-3 text-right text-xs font-medium text-gray-500 dark:text-gray-300 uppercase tracking-wider">
                Akce
              </th>
            </tr>
          </thead>
          <tbody className="bg-white dark:bg-gray-800 divide-y divide-gray-200 dark:divide-gray-700">
            {videos.length === 0 ? (
              <tr>
                <td colSpan={4} className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 text-center">
                  Nebyla nalezena ≈æ√°dn√° videa.
                </td>
              </tr>
            ) : (
              videos.map((video) => (
                <tr key={video.id} className="hover:bg-gray-50 dark:hover:bg-gray-700">
                  <td className="px-6 py-4 whitespace-nowrap">
                    <div className="text-sm font-medium text-gray-900 dark:text-white">{video.title}</div>
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">
                    {new Date(video.createdAt).toLocaleDateString('cs-CZ')}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-sm text-gray-500 dark:text-gray-300">
                    {new Date(video.updatedAt).toLocaleDateString('cs-CZ')}
                  </td>
                  <td className="px-6 py-4 whitespace-nowrap text-right text-sm font-medium space-x-4">
                    <Link
                      href={`/admin/edit/${video.id}`}
                      className="text-indigo-500 hover:text-indigo-700 hover:underline"
                    >
                      Editovat
                    </Link>
                    <DeleteButton videoId={video.id} />
                  </td>
                </tr>
              ))
            )}
          </tbody>
        </table>
      </div>
    </main>
  );
}
```

### `app/admin/add/page.tsx`

```typescript
"use client";

import { useState, FormEvent } from 'react';

export default function AddVideoPage() {
  const [youtubeUrl, setYoutubeUrl] = useState('');
  const [title, setTitle] = useState('');
  const [summary, setSummary] = useState('');
  const [transcript, setTranscript] = useState('');
  const [structuredContent, setStructuredContent] = useState('');

  const [isLoading, setIsLoading] = useState(false); 
  const [isFetching, setIsFetching] = useState(false);
  const [isAiGenerating, setIsAiGenerating] = useState(false); // Stav pro AI

  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [fetchWarning, setFetchWarning] = useState<string | null>(null);
  
  // √ölo≈æi≈°tƒõ pro debug logy
  const [debugLogs, setDebugLogs] = useState<string[]>([]);

  const addLog = (msg: string) => {
     const timestamp = new Date().toLocaleTimeString();
     setDebugLogs(prev => [`[${timestamp}] ${msg}`, ...prev]);
  };

  const handleFetchFromYoutube = async () => {
    if (!youtubeUrl) return;
    
    setIsFetching(true);
    setFetchWarning(null);
    setError(null);
    setDebugLogs([]); 
    addLog(`Start request for URL: ${youtubeUrl}`);

    try {
      const res = await fetch(`/api/youtube/fetch-data?url=${encodeURIComponent(youtubeUrl)}`);
      const data = await res.json();

      if (data.debugLogs) {
          setDebugLogs(prev => [...data.debugLogs, ...prev]);
      }

      if (!res.ok) {
        throw new Error(data.message || 'Nepoda≈ôilo se st√°hnout data z YouTube');
      }

      if (data.title) setTitle(data.title);
      if (data.description) setSummary(data.description);
      
      if (typeof data.transcript === 'string') {
        setTranscript(data.transcript);
        addLog(`P≈ôepis sta≈æen (${data.transcript.length} znak≈Ø)`);
      } else {
        setFetchWarning('Metadata sta≈æena, ale titulky nebyly nalezeny.');
      }

      if (data.warning) {
         setFetchWarning(data.warning);
      }

    } catch (err: any) {
      console.error(err);
      setError(err.message);
      addLog(`Chyba YT: ${err.message}`);
    } finally {
      setIsFetching(false);
    }
  };

  // --- TOTO JE TA UPRAVEN√Å FUNKCE PRO AI ---
  const handleAiGenerate = async () => {
    if (!transcript) return;

    setIsAiGenerating(true);
    setError(null);
    // Vyƒçist√≠me star√© logy a≈• vid√≠me jen AI akci
    setDebugLogs([]); 
    addLog('‚ö° Inicializace AI modelu...');
    addLog('üìÑ Odes√≠l√°m p≈ôepis na server...');

    try {
      const res = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ transcript }),
      });

      addLog(`üì° Server odpovƒõdƒõl: Status ${res.status} ${res.statusText}`);

      // 1. P≈ôeƒçteme odpovƒõƒè jako text (raw), abychom vidƒõli, co server poslal
      const rawText = await res.text();
      addLog(`üì¶ P≈ôijato dat: ${rawText.length} znak≈Ø`);

      // 2. Zkus√≠me to parsovat jako JSON
      let data;
      try {
          data = JSON.parse(rawText);
      } catch (e) {
          console.error("JSON Parse Error:", e);
          console.log("Raw Text:", rawText);
          throw new Error(`Server nevr√°til platn√Ω JSON. P≈ôi≈°lo: "${rawText.substring(0, 50)}..."`);
      }

      if (!res.ok) {
        throw new Error(data.message || 'Chyba p≈ôi generov√°n√≠ obsahu');
      }

      // 3. Kontrola obsahu
      if (!data.content) {
          addLog('‚ö†Ô∏è Varov√°n√≠: Pole "content" v odpovƒõdi je pr√°zdn√©!');
      } else {
          addLog(`‚úÖ Obsah v po≈ô√°dku (${data.content.length} znak≈Ø). Vkl√°d√°m...`);
          setStructuredContent(data.content);
      }
      
    } catch (err: any) {
      console.error(err);
      addLog(`‚ùå KRITICK√Å CHYBA: ${err.message}`);
      setError(`Chyba AI: ${err.message}`);
    } finally {
      setIsAiGenerating(false);
    }
  };
  // -----------------------------------------

  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsLoading(true);
    setError(null);
    setSuccess(null);

    try {
      const res = await fetch('/api/videos', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          youtubeUrl,
          title,
          summary,
          transcript, 
          structuredContent,
        }),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.message || 'Nƒõco se pokazilo');
      }

      setSuccess('Video bylo √∫spƒõ≈°nƒõ p≈ôid√°no!');
      setYoutubeUrl('');
      setTitle('');
      setSummary('');
      setTranscript('');
      setStructuredContent('');
      setFetchWarning(null);
      setDebugLogs([]);
    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="max-w-2xl mx-auto p-4 sm:p-6 lg:p-8">
      <h1 className="text-2xl font-bold mb-6">P≈ôidat nov√© video</h1>
      
      {/* DIAGNOSTICK√ù LOG PANEL */}
      {debugLogs.length > 0 && (
        <div className="mb-6 p-3 bg-black border border-gray-700 rounded font-mono text-xs text-green-400 max-h-48 overflow-y-auto shadow-inner">
            <strong className="block mb-1 text-gray-500 border-b border-gray-800 pb-1">SYSTEM LOG:</strong>
            {debugLogs.map((log, i) => (
                <div key={i} className="py-0.5 border-b border-gray-900 last:border-0">{log}</div>
            ))}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-6">
        
        <div>
          <label htmlFor="youtubeUrl" className="block text-sm font-medium text-gray-300">
            YouTube URL
          </label>
          <div className="mt-1 flex gap-2">
            <input
              type="text"
              id="youtubeUrl"
              value={youtubeUrl}
              onChange={(e) => setYoutubeUrl(e.target.value)}
              required
              className="block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2"
              placeholder="https://www.youtube.com/watch?v=..."
            />
            <button
              type="button"
              onClick={handleFetchFromYoutube}
              disabled={isFetching || !youtubeUrl}
              className="shrink-0 bg-blue-600 hover:bg-blue-700 text-white font-medium py-2 px-4 rounded disabled:opacity-50 disabled:cursor-not-allowed transition-colors flex items-center"
            >
              {isFetching ? 'Naƒç√≠t√°m...' : 'Naƒç√≠st data z YouTube'}
            </button>
          </div>
          {fetchWarning && (
            <p className="mt-2 text-sm text-yellow-400">{fetchWarning}</p>
          )}
        </div>

        <div>
          <label htmlFor="title" className="block text-sm font-medium text-gray-300">
            N√°zev videa
          </label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2"
          />
        </div>

        <div>
          <label htmlFor="summary" className="block text-sm font-medium text-gray-300">
            Shrnut√≠ / Popis
          </label>
          <textarea
            id="summary"
            rows={5}
            value={summary}
            onChange={(e) => setSummary(e.target.value)}
            required
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2"
          />
        </div>

        <div>
          <label htmlFor="transcript" className="block text-sm font-medium text-gray-300">
            P≈ôepis videa (Transcript)
          </label>
          <textarea
            id="transcript"
            rows={8}
            value={transcript}
            onChange={(e) => setTranscript(e.target.value)}
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2 text-sm font-mono bg-gray-900"
          />
        </div>

        {/* TLAƒå√çTKO PRO AI GENERATOR */}
        <div>
            <div className="flex justify-between items-end mb-2">
                <label htmlFor="structuredContent" className="block text-sm font-medium text-gray-300">
                    Strukturovan√Ω Obsah (Kapitoly)
                </label>
                
                <button
                    type="button"
                    onClick={handleAiGenerate}
                    disabled={!transcript || isAiGenerating}
                    className={`text-xs font-bold py-1 px-3 rounded transition-colors flex items-center gap-2 ${
                        !transcript 
                        ? 'bg-gray-700 text-gray-400 cursor-not-allowed' 
                        : 'bg-purple-600 hover:bg-purple-700 text-white shadow-lg shadow-purple-900/20'
                    }`}
                >
                    {isAiGenerating ? (
                    <>
                        <span className="animate-spin">‚öôÔ∏è</span> Generuji...
                    </>
                    ) : (
                    <>
                        ‚ú® Vytvo≈ôit obsah pomoc√≠ AI
                    </>
                    )}
                </button>
            </div>

            <textarea
                id="structuredContent"
                rows={10}
                value={structuredContent}
                onChange={(e) => setStructuredContent(e.target.value)}
                className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2 font-mono"
                placeholder="Zde se objev√≠ vygenerovan√Ω obsah..."
            />
        </div>

        <div>
          <button
            type="submit"
            disabled={isLoading}
            className="w-full inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50"
          >
            {isLoading ? 'Ukl√°d√°n√≠...' : 'Ulo≈æit video'}
          </button>
        </div>
      </form>

      {success && <p className="mt-4 text-sm text-green-500 text-center font-bold">{success}</p>}
      {error && <p className="mt-4 text-sm text-red-500 text-center font-bold">{error}</p>}
    </div>
  );
}
```

### `app/admin/edit/[id]/page.tsx`

```typescript
"use client";

import { useState, FormEvent, useEffect } from 'react';
import { useRouter, useParams } from 'next/navigation';

interface Collection {
  id: string;
  name: string;
}

interface VideoData {
  youtubeId: string;
  title: string;
  summary: string;
  transcript?: string | null;
  chapters?: { text: string }[];
  collections?: Collection[];
}

export default function EditVideoPage() {
  const router = useRouter();
  const params = useParams();
  const id = params.id as string;

  // --- Stavy formul√°≈ôe ---
  const [title, setTitle] = useState('');
  const [summary, setSummary] = useState('');
  const [transcript, setTranscript] = useState('');
  const [structuredContent, setStructuredContent] = useState('');
  
  // --- Stavy pro sb√≠rky ---
  const [allCollections, setAllCollections] = useState<Collection[]>([]);
  const [selectedCollectionIds, setSelectedCollectionIds] = useState<string[]>([]);

  // --- Stavy UI ---
  const [youtubeId, setYoutubeId] = useState('');
  const [isPageLoading, setIsPageLoading] = useState(true);
  const [isSubmitting, setIsSubmitting] = useState(false);
  const [isFetching, setIsFetching] = useState(false);
  
  // NOV√â: Stav pro AI
  const [isAiGenerating, setIsAiGenerating] = useState(false);
  
  const [error, setError] = useState<string | null>(null);
  const [success, setSuccess] = useState<string | null>(null);
  const [fetchWarning, setFetchWarning] = useState<string | null>(null);

  // LOGOV√ÅN√ç (Stejn√© jako v Add page)
  const [debugLogs, setDebugLogs] = useState<string[]>([]);
  const addLog = (msg: string) => {
      const timestamp = new Date().toLocaleTimeString();
      setDebugLogs(prev => [`[${timestamp}] ${msg}`, ...prev]);
  };

  // 1. Naƒçten√≠ dat p≈ôi startu
  useEffect(() => {
    if (!id) return;

    const loadData = async () => {
      setIsPageLoading(true);
      try {
        const [videoRes, collectionsRes] = await Promise.all([
          fetch(`/api/videos/${id}`),
          fetch('/api/collections')
        ]);

        if (!videoRes.ok) throw new Error('Nepoda≈ôilo se naƒç√≠st data videa.');
        if (!collectionsRes.ok) throw new Error('Nepoda≈ôilo se naƒç√≠st seznam sb√≠rek.');

        const videoData: VideoData = await videoRes.json();
        const collectionsData: Collection[] = await collectionsRes.json();

        setTitle(videoData.title);
        setSummary(videoData.summary);
        setYoutubeId(videoData.youtubeId);
        if (videoData.transcript) setTranscript(videoData.transcript);

        let content = '';
        if (videoData.chapters && videoData.chapters.length > 0) {
          content = videoData.chapters.map((ch: any) => ch.text).join('\n');
        }
        setStructuredContent(content);

        setAllCollections(collectionsData);
        if (videoData.collections) {
          const initialIds = videoData.collections.map(col => col.id);
          setSelectedCollectionIds(initialIds);
        }

      } catch (err: any) {
        setError(err.message);
      } finally {
        setIsPageLoading(false);
      }
    };

    loadData();
  }, [id]);

  const toggleCollection = (collectionId: string) => {
    setSelectedCollectionIds(prev => {
      if (prev.includes(collectionId)) {
        return prev.filter(id => id !== collectionId);
      } else {
        return [...prev, collectionId];
      }
    });
  };

  // 2. Naƒçten√≠ z YouTube (Refresh)
  const handleFetchFromYoutube = async () => {
    if (!youtubeId) return;

    const reconstructedUrl = `https://www.youtube.com/watch?v=${youtubeId}`;
    
    setIsFetching(true);
    setFetchWarning(null);
    setDebugLogs([]);
    addLog(`Aktualizuji data pro ID: ${youtubeId}`);
    
    try {
      const res = await fetch(`/api/youtube/fetch-data?url=${encodeURIComponent(reconstructedUrl)}`);
      const data = await res.json();

      if (data.debugLogs) {
          setDebugLogs(prev => [...data.debugLogs, ...prev]);
      }

      if (!res.ok) throw new Error(data.message || 'Chyba p≈ôi stahov√°n√≠');

      if (!title || confirm('Chcete p≈ôepsat st√°vaj√≠c√≠ N√ÅZEV nov√Ωm z YouTube?')) {
         if (data.title) setTitle(data.title);
      }
      if (!summary || confirm('Chcete p≈ôepsat st√°vaj√≠c√≠ SHRNUT√ç nov√Ωm z YouTube?')) {
         if (data.description) setSummary(data.description);
      }
      
      if (data.transcript) {
        if (!transcript || confirm('Chcete nahradit st√°vaj√≠c√≠ P≈òEPIS novƒõ sta≈æen√Ωm?')) {
           setTranscript(data.transcript);
           addLog('P≈ôepis aktualizov√°n.');
        }
      } else {
        setFetchWarning('Metadata sta≈æena, ale titulky nebyly nalezeny.');
      }

    } catch (err: any) {
      addLog(`Chyba: ${err.message}`);
      alert('Chyba: ' + err.message);
    } finally {
      setIsFetching(false);
    }
  };

  // 3. AI GENERATOR (Robustn√≠ verze)
  const handleAiGenerate = async () => {
    if (!transcript) return;

    setIsAiGenerating(true);
    setFetchWarning(null);
    setDebugLogs([]); // Reset logu pro ƒçist√Ω p≈ôehled AI akce
    addLog('‚ö° Inicializace AI modelu...');
    addLog('üìÑ Odes√≠l√°m p≈ôepis na server...');

    try {
      const res = await fetch('/api/ai/generate', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ transcript }),
      });

      addLog(`üì° Server odpovƒõdƒõl: Status ${res.status}`);
      const rawText = await res.text();
      
      let data;
      try {
          data = JSON.parse(rawText);
      } catch (e) {
          throw new Error('Server nevr√°til platn√Ω JSON. Viz konzole.');
      }

      if (!res.ok) {
        throw new Error(data.message || 'Chyba p≈ôi generov√°n√≠ obsahu');
      }

      if (structuredContent && !confirm('Pole ji≈æ obsahuje data. Chcete je p≈ôepsat v√Ωstupem z AI?')) {
          addLog('‚ö†Ô∏è Operace zru≈°ena u≈æivatelem.');
          return;
      }

      if (data.content) {
        setStructuredContent(data.content);
        addLog(`‚úÖ Obsah v po≈ô√°dku (${data.content.length} znak≈Ø). Vlo≈æeno.`);
        setSuccess('AI obsah byl vygenerov√°n.');
      }

    } catch (err: any) {
      console.error(err);
      addLog(`‚ùå Chyba: ${err.message}`);
      setError(`Chyba AI: ${err.message}`);
    } finally {
      setIsAiGenerating(false);
    }
  };

  // 4. Odesl√°n√≠ formul√°≈ôe
  const handleSubmit = async (e: FormEvent) => {
    e.preventDefault();
    setIsSubmitting(true);
    setError(null);
    setSuccess(null);

    try {
      const res = await fetch(`/api/videos/${id}`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({
          title,
          summary,
          transcript,
          structuredContent,
          collectionIds: selectedCollectionIds,
        }),
      });

      const data = await res.json();

      if (!res.ok) {
        throw new Error(data.message || 'Aktualizace se nezda≈ôila');
      }

      setSuccess('Z√°znam byl √∫spƒõ≈°nƒõ aktualizov√°n!');
      setDebugLogs([]);
      
      setTimeout(() => {
        router.push('/admin/manage');
      }, 1500);

    } catch (err: any) {
      setError(err.message);
    } finally {
      setIsSubmitting(false);
    }
  };

  if (isPageLoading) {
    return <p className="text-center p-8 text-gray-400">Naƒç√≠t√°n√≠ dat videa a sb√≠rek...</p>;
  }

  return (
    <div className="max-w-2xl mx-auto p-4 sm:p-6 lg:p-8">
      <div className="flex justify-between items-center mb-6">
        <h1 className="text-2xl font-bold">Upravit video</h1>
        
        <button
           type="button"
           onClick={handleFetchFromYoutube}
           disabled={isFetching}
           className="text-xs bg-gray-700 hover:bg-gray-600 text-gray-200 py-1 px-3 rounded flex items-center gap-2 transition-colors"
        >
           {isFetching ? 'Stahuji...' : '‚Üª Aktualizovat data z YouTube'}
        </button>
      </div>

      {/* DIAGNOSTICK√ù LOG PANEL */}
      {debugLogs.length > 0 && (
        <div className="mb-6 p-3 bg-black border border-gray-700 rounded font-mono text-xs text-green-400 max-h-48 overflow-y-auto shadow-inner">
            <strong className="block mb-1 text-gray-500 border-b border-gray-800 pb-1">SYSTEM LOG:</strong>
            {debugLogs.map((log, i) => (
                <div key={i} className="py-0.5 border-b border-gray-900 last:border-0">{log}</div>
            ))}
        </div>
      )}

      <form onSubmit={handleSubmit} className="space-y-6">

        {/* YouTube ID (Read-only) */}
        <div>
          <label className="block text-sm font-medium text-gray-300">
            YouTube ID
          </label>
          <input
            type="text"
            value={youtubeId}
            disabled
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-900 shadow-sm text-gray-400 p-2 cursor-not-allowed"
          />
          {fetchWarning && <p className="text-xs text-yellow-400 mt-1">{fetchWarning}</p>}
        </div>

        {/* N√°zev */}
        <div>
          <label htmlFor="title" className="block text-sm font-medium text-gray-300">
            N√°zev videa
          </label>
          <input
            type="text"
            id="title"
            value={title}
            onChange={(e) => setTitle(e.target.value)}
            required
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2"
          />
        </div>

        {/* Shrnut√≠ */}
        <div>
          <label htmlFor="summary" className="block text-sm font-medium text-gray-300">
            Shrnut√≠ / Popis
          </label>
          <textarea
            id="summary"
            rows={5}
            value={summary}
            onChange={(e) => setSummary(e.target.value)}
            required
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2"
          />
        </div>

        {/* --- SB√çRKY --- */}
        <div className="bg-gray-900 p-4 rounded-md border border-gray-700">
          <h3 className="text-sm font-medium text-gray-300 mb-3">Za≈ôadit do sb√≠rek</h3>
          
          {allCollections.length === 0 ? (
            <p className="text-sm text-gray-500 italic">Zat√≠m nem√°te vytvo≈ôeny ≈æ√°dn√© sb√≠rky.</p>
          ) : (
            <div className="space-y-2 max-h-48 overflow-y-auto pr-2 custom-scrollbar">
              {allCollections.map((collection) => (
                <label key={collection.id} className="flex items-center space-x-3 cursor-pointer hover:bg-gray-800 p-2 rounded transition-colors">
                  <input
                    type="checkbox"
                    checked={selectedCollectionIds.includes(collection.id)}
                    onChange={() => toggleCollection(collection.id)}
                    className="h-4 w-4 rounded border-gray-600 text-indigo-600 focus:ring-indigo-500 bg-gray-700"
                  />
                  <span className="text-sm text-gray-200">{collection.name}</span>
                </label>
              ))}
            </div>
          )}
        </div>

        {/* P≈ôepis videa */}
        <div>
          <label htmlFor="transcript" className="block text-sm font-medium text-gray-300">
            P≈ôepis videa (Transcript)
          </label>
          <textarea
            id="transcript"
            rows={8}
            value={transcript}
            onChange={(e) => setTranscript(e.target.value)}
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2 text-sm font-mono bg-gray-900"
            placeholder="Zde se objev√≠ sta≈æen√Ω p≈ôepis titulk≈Ø..."
          />
          <p className="mt-1 text-xs text-gray-500">
             Tento text bude pou≈æit pro AI generov√°n√≠ kapitol.
          </p>
        </div>

        {/* Strukturovan√Ω obsah */}
        <div>
            <div className="flex justify-between items-end mb-1">
                <label htmlFor="structuredContent" className="block text-sm font-medium text-gray-300">
                    Strukturovan√Ω Obsah (Kapitoly)
                </label>
                
                <button
                    type="button"
                    onClick={handleAiGenerate}
                    disabled={!transcript || isAiGenerating}
                    className={`text-xs font-bold py-1 px-3 rounded transition-colors flex items-center gap-2 ${
                        !transcript 
                        ? 'bg-gray-700 text-gray-400 cursor-not-allowed' 
                        : 'bg-purple-600 hover:bg-purple-700 text-white shadow-lg shadow-purple-900/20'
                    }`}
                >
                    {isAiGenerating ? (
                    <>
                        <span className="animate-spin">‚öôÔ∏è</span> Generuji...
                    </>
                    ) : (
                    <>
                        ‚ú® Vytvo≈ôit obsah pomoc√≠ AI
                    </>
                    )}
                </button>
            </div>

          <textarea
            id="structuredContent"
            rows={15}
            value={structuredContent}
            onChange={(e) => setStructuredContent(e.target.value)}
            className="mt-1 block w-full rounded-md border-gray-600 bg-gray-800 shadow-sm focus:border-indigo-500 focus:ring-indigo-500 text-white p-2 font-mono"
          />
          <p className="mt-2 text-xs text-gray-400">
            Form√°t: "1.1. Text (MM:SS - MM:SS)".
          </p>
        </div>

        {/* Submit Button */}
        <div>
          <button
            type="submit"
            disabled={isSubmitting}
            className="inline-flex justify-center rounded-md border border-transparent bg-indigo-600 py-2 px-4 text-sm font-medium text-white shadow-sm hover:bg-indigo-700 focus:outline-none focus:ring-2 focus:ring-indigo-500 focus:ring-offset-2 disabled:opacity-50 w-full sm:w-auto"
          >
            {isSubmitting ? 'Ukl√°d√°n√≠...' : 'Ulo≈æit zmƒõny'}
          </button>
        </div>
      </form>

      {success && (
        <div className="mt-4 p-3 bg-green-900/30 border border-green-500 rounded text-green-400 text-sm text-center">
          {success}
        </div>
      )}
      {error && (
        <div className="mt-4 p-3 bg-red-900/30 border border-red-500 rounded text-red-400 text-sm text-center">
          {error}
        </div>
      )}
    </div>
  );
}
```

### `app/admin/collections/page.tsx`

```typescript
"use client";
import { useState, useEffect, FormEvent } from 'react';
import { useSession } from 'next-auth/react';

// Typ pro Collection
interface Collection {
  id: string;
  name: string;
  description: string | null;
  isPublic: boolean;
  _count?: { videos: number };
}

export default function CollectionsPage() {
  const { data: session } = useSession();
  const [collections, setCollections] = useState<Collection[]>([]);
  const [name, setName] = useState('');
  const [desc, setDesc] = useState('');
  const [loading, setLoading] = useState(false);

  // 1. Naƒçten√≠ sb√≠rek
  const fetchCollections = async () => {
    const res = await fetch('/api/collections');
    if (res.ok) setCollections(await res.json());
  };

  useEffect(() => { fetchCollections(); }, []);

  // 2. Vytvo≈ôen√≠ sb√≠rky
  const handleCreate = async (e: FormEvent) => {
    e.preventDefault();
    setLoading(true);
    await fetch('/api/collections', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, description: desc }),
    });
    setName(''); setDesc('');
    fetchCollections(); // Refresh tabulky
    setLoading(false);
  };

  // 3. P≈ôepnut√≠ ve≈ôejnosti (isPublic)
  const togglePublic = async (col: Collection) => {
    await fetch(`/api/collections/${col.id}`, {
      method: 'PUT',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ isPublic: !col.isPublic }),
    });
    fetchCollections();
  };

  // 4. Smaz√°n√≠
  const handleDelete = async (id: string) => {
    if (!confirm('Opravdu smazat sb√≠rku?')) return;
    await fetch(`/api/collections/${id}`, { method: 'DELETE' });
    fetchCollections();
  };

  if (session?.user.role !== 'ADMIN') return <p>Access Denied</p>;

  return (
    <div className="max-w-4xl mx-auto p-6">
      <h1 className="text-3xl font-bold mb-6">Spr√°va Sb√≠rek</h1>
      
      {/* Formul√°≈ô pro p≈ôid√°n√≠ */}
      <form onSubmit={handleCreate} className="bg-gray-800 p-4 rounded mb-8 space-y-4">
        <h2 className="text-xl font-semibold">Nov√° Sb√≠rka</h2>
        <div>
            <label className="block text-sm text-gray-400">N√°zev</label>
            <input className="w-full p-2 rounded bg-gray-700" value={name} onChange={e => setName(e.target.value)} required />
        </div>
        <div>
            <label className="block text-sm text-gray-400">Popis</label>
            <input className="w-full p-2 rounded bg-gray-700" value={desc} onChange={e => setDesc(e.target.value)} />
        </div>
        <button disabled={loading} className="bg-indigo-600 px-4 py-2 rounded hover:bg-indigo-700 text-white">
            {loading ? 'Vytv√°≈ô√≠m...' : 'Vytvo≈ôit Sb√≠rku'}
        </button>
      </form>

      {/* Seznam sb√≠rek */}
      <div className="space-y-4">
        {collections.map(col => (
            <div key={col.id} className="bg-gray-900 border border-gray-700 p-4 rounded flex justify-between items-center">
                <div>
                    <h3 className="font-bold text-lg">{col.name}</h3>
                    <p className="text-sm text-gray-400">{col.description}</p>
                    <span className="text-xs bg-gray-700 px-2 py-1 rounded mt-1 inline-block">
                        Poƒçet vide√≠: {col._count?.videos || 0}
                    </span>
                </div>
                <div className="flex items-center gap-4">
                    <button 
                        onClick={() => togglePublic(col)}
                        className={`px-3 py-1 rounded text-sm ${col.isPublic ? 'bg-green-900 text-green-300' : 'bg-yellow-900 text-yellow-300'}`}
                    >
                        {col.isPublic ? 'VE≈òEJN√Å' : 'SOUKROM√Å'}
                    </button>
                    <button onClick={() => handleDelete(col.id)} className="text-red-500 hover:underline">Smazat</button>
                </div>
            </div>
        ))}
      </div>
    </div>
  );
}
```

### `app/api/auth/[...nextauth]/route.ts`

```typescript
import NextAuth, { AuthOptions } from "next-auth"; // <-- Importujeme AuthOptions
import { PrismaClient } from "@prisma/client";
import CredentialsProvider from "next-auth/providers/credentials";
import * as bcrypt from "bcrypt";

const prisma = new PrismaClient();

// Explicitnƒõ typujeme na≈°e volby, aby TypeScript mohl odvodit
// typy pro v≈°echny callbacky (t√≠m se zbav√≠me chyby 'any').
export const authOptions: AuthOptions = {
  providers: [
    CredentialsProvider({
      name: "Credentials",
      credentials: {
        email: { label: "Email", type: "email" },
        password: { label: "Password", type: "password" },
      },
      async authorize(credentials) {
        if (!credentials?.email || !credentials?.password) {
          return null;
        }

        const user = await prisma.user.findUnique({
          where: { email: credentials.email },
        });

        if (!user) {
          return null;
        }

        const isPasswordValid = await bcrypt.compare(
          credentials.password,
          user.password
        );

        if (!isPasswordValid) {
          return null;
        }

        // Vrac√≠me objekt, kter√Ω odpov√≠d√° na≈°√≠ roz≈°√≠≈ôen√© definici 'User'
        // (viz types/next-auth.d.ts)
        return {
          id: user.id,
          email: user.email,
          role: user.role, // Prisma enum (USER/ADMIN) je kompatibiln√≠ se stringem
        };
      },
    }),
  ],
  session: {
    strategy: "jwt",
  },
  callbacks: {
    // D√≠ky AuthOptions a typov√©mu souboru ji≈æ TypeScript v√≠,
    // ≈æe 'token' je JWT a 'user' je n√°≈° roz≈°√≠≈ôen√Ω User.
    async jwt({ token, user }) {
      // P≈ôi prvn√≠m p≈ôihl√°≈°en√≠ (kdy 'user' existuje) p≈ôeneseme data do tokenu
      if (user) {
        token.id = user.id;
        token.role = user.role;
      }
      return token;
    },
    // Zde p≈ôeneseme data z tokenu (kter√Ω je v cookie) do session
    // (kterou vid√≠ klient)
    async session({ session, token }) {
      if (session.user) {
        session.user.id = token.id;
        session.user.role = token.role;
      }
      return session;
    },
  },
  pages: {
    signIn: "/login",
  },
};

const handler = NextAuth(authOptions);

export { handler as GET, handler as POST };

```

### `app/api/videos/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { parseStructuredContent } from '@/lib/parser';

const globalForPrisma = global as unknown as { prisma: PrismaClient };
const prisma = globalForPrisma.prisma || new PrismaClient();
if (process.env.NODE_ENV !== 'production') globalForPrisma.prisma = prisma;

function extractYouTubeId(url: string): string | null {
  const regex =
    /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
  const match = url.match(regex);
  return match ? match[1] : null;
}

export async function POST(request: Request) {
  try {
    // 1. Ovƒõ≈ôen√≠ sezen√≠ a role
    const session = await getServerSession(authOptions);

    if (!session || session.user?.role !== 'ADMIN') {
      return new NextResponse(JSON.stringify({ message: 'Unauthorized' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // 2. Zpracov√°n√≠ po≈æadavku
    const body = await request.json();
    // NOV√â: P≈ôij√≠m√°me i 'transcript'
    const { youtubeUrl, title, summary, structuredContent, transcript } = body;

    if (!youtubeUrl || !title || !summary) {
      return new NextResponse(JSON.stringify({ message: 'Missing required fields' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    const youtubeId = extractYouTubeId(youtubeUrl);
    if (!youtubeId) {
      return new NextResponse(JSON.stringify({ message: 'Invalid YouTube URL' }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }

    // 3. Parsov√°n√≠ kapitol
    const parsedChapters = parseStructuredContent(structuredContent || '');

    // 4. Transakce (Video + Transcript + Kapitoly)
    const newVideo = await prisma.$transaction(async (tx) => {
      // A. Vytvo≈ôen√≠ videa
      const video = await tx.video.create({
        data: {
          youtubeId: youtubeId,
          title: title,
          summary: summary,
          authorId: session.user.id,
        },
      });

      // B. Ulo≈æen√≠ p≈ôepisu (pokud existuje) - NOV√â
      if (transcript && transcript.trim() !== '') {
        await tx.transcript.create({
          data: {
            videoId: video.id,
            content: transcript,
            language: 'cs', // Defaultnƒõ p≈ôedpokl√°d√°me ƒçe≈°tinu, nebo dle detekce
          }
        });
      }

      // C. Vytvo≈ôen√≠ kapitol
      if (parsedChapters.length > 0) {
        const chapterData = parsedChapters.map((chapter, index) => ({
          ...chapter,
          order: index,
          videoId: video.id,
        }));

        await tx.chapter.createMany({
          data: chapterData,
        });
      }

      return video;
    });

    return new NextResponse(JSON.stringify(newVideo), {
      status: 201,
      headers: { 'Content-Type': 'application/json' },
    });

  } catch (error) {
    if (error instanceof Error) {
      if (error.message.startsWith('Neplatn√Ω form√°t ≈ô√°dku')) {
        return new NextResponse(JSON.stringify({ message: error.message }), {
          status: 400,
          headers: { 'Content-Type': 'application/json' },
        });
      }
      if ((error as any).code === 'P2002') {
        return new NextResponse(JSON.stringify({ message: 'Video with this ID already exists' }), {
          status: 409,
          headers: { 'Content-Type': 'application/json' },
        });
      }
    }

    console.error('API_VIDEOS_POST_ERROR', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Server Error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
```

### `app/api/videos/[id]/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { parseStructuredContent } from '@/lib/parser';

const prisma = new PrismaClient();

async function checkPermissions(
  videoId: string,
  session: any
): Promise<{ allowed: boolean; video: any; error?: NextResponse }> {
  if (!session) {
    return {
      allowed: false,
      video: null,
      error: new NextResponse(JSON.stringify({ message: 'Unauthorized' }), {
        status: 401,
        headers: { 'Content-Type': 'application/json' },
      }),
    };
  }

  // √öPRAVA: Naƒç√≠t√°me i transcript a collections
  const video = await prisma.video.findUnique({
    where: { id: videoId },
    include: { 
      chapters: { orderBy: { order: 'asc' } },
      collections: true,
      transcript: true // NOV√â: Naƒçten√≠ p≈ôepisu
    },
  });

  if (!video) {
    return {
      allowed: false,
      video: null,
      error: new NextResponse(JSON.stringify({ message: 'Video not found' }), {
        status: 404,
        headers: { 'Content-Type': 'application/json' },
      }),
    };
  }

  const isOwner = video.authorId === session.user.id;
  const isAdmin = session.user.role === 'ADMIN';

  if (!isOwner && !isAdmin) {
    return {
      allowed: false,
      video: video,
      error: new NextResponse(JSON.stringify({ message: 'Forbidden' }), {
        status: 403,
        headers: { 'Content-Type': 'application/json' },
      }),
    };
  }

  // Zplo≈°tƒõn√≠ struktury pro frontend (aby transcript byl p≈ô√≠mo string, ne objekt)
  // Toto nen√≠ nutn√©, pokud frontend poƒç√≠t√° s objektem, ale pro jednoduchost:
  const videoResponse = {
    ...video,
    transcript: video.transcript?.content || null // Vr√°t√≠me jen text nebo null
  };

  return { allowed: true, video: videoResponse };
}

export async function GET(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    const params = await context.params;
    const { id } = params; 

    const { allowed, video, error } = await checkPermissions(id, session);
    if (!allowed) return error;

    return NextResponse.json(video);
  } catch (error) {
    console.error('API_VIDEOS_GET_ERROR', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Server Error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}

export async function PUT(
  request: Request,
  context: { params: Promise<{ id:string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    const params = await context.params;
    const { id } = params;

    const { allowed, error } = await checkPermissions(id, session);
    if (!allowed) return error;

    const body = await request.json();
    // NOV√â: Naƒç√≠t√°me i transcript
    const { title, summary, structuredContent, collectionIds, transcript } = body;

    const parsedChapters = parseStructuredContent(structuredContent || '');

    const updatedVideo = await prisma.$transaction(async (tx) => {
      // 1. Aktualizace videa
      const video = await tx.video.update({
        where: { id: id },
        data: {
          title,
          summary,
          updatedAt: new Date(),
          collections: collectionIds ? {
            set: collectionIds.map((cid: string) => ({ id: cid }))
          } : undefined,
        },
      });

      // 2. Aktualizace / Vytvo≈ôen√≠ p≈ôepisu (Upsert) - NOV√â
      if (transcript !== undefined) {
        if (transcript.trim() === '') {
            // Pokud je pr√°zdn√Ω, m≈Ø≈æeme ho smazat, aby nezab√≠ral m√≠sto? 
            // Pro teƒè radƒõji aktualizujeme na pr√°zdn√Ω string nebo nech√°me b√Ωt.
            // Pou≈æijeme upsert, kter√Ω zvl√°dne oboj√≠.
        }
        
        await tx.transcript.upsert({
          where: { videoId: id },
          create: {
            videoId: id,
            content: transcript,
          },
          update: {
            content: transcript,
          },
        });
      }

      // 3. Aktualizace kapitol
      await tx.chapter.deleteMany({
        where: { videoId: id },
      });

      if (parsedChapters.length > 0) {
        const chapterData = parsedChapters.map((chapter, index) => ({
          ...chapter,
          order: index,
          videoId: id,
        }));
        await tx.chapter.createMany({
          data: chapterData,
        });
      }

      return video;
    });

    return NextResponse.json(updatedVideo);
  } catch (error: any) {
    if (error.message.startsWith('Neplatn√Ω form√°t ≈ô√°dku')) {
      return new NextResponse(JSON.stringify({ message: error.message }), {
        status: 400,
        headers: { 'Content-Type': 'application/json' },
      });
    }
    console.error('API_VIDEOS_PUT_ERROR', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Server Error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}

export async function DELETE(
  request: Request,
  context: { params: Promise<{ id: string }> }
) {
  try {
    const session = await getServerSession(authOptions);
    const params = await context.params;
    const { id } = params;

    const { allowed, error } = await checkPermissions(id, session);
    if (!allowed) return error;

    // D√≠ky onDelete: Cascade v Prisma sch√©matu se Transcript sma≈æe automaticky
    await prisma.video.delete({
      where: { id: id },
    });

    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error('API_VIDEOS_DELETE_ERROR', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Server Error' }), {
      status: 500,
      headers: { 'Content-Type': 'application/json' },
    });
  }
}
```

### `app/api/collections/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

const prisma = new PrismaClient();

// POST: Vytvo≈ôen√≠ nov√© sb√≠rky
export async function POST(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session || session.user?.role !== 'ADMIN') { 
      return new NextResponse(JSON.stringify({ message: 'Unauthorized' }), { status: 403 });
    }

    const body = await request.json();
    const { name, description } = body;

    if (!name) {
      return new NextResponse(JSON.stringify({ message: 'Name is required' }), { status: 400 });
    }

    const collection = await prisma.collection.create({
      data: {
        name,
        description,
        authorId: session.user.id,
        isPublic: false,
      },
    });

    return NextResponse.json(collection, { status: 201 });
  } catch (error) {
    console.error('API_COLLECTIONS_POST_ERROR', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Error' }), { status: 500 });
  }
}

// GET: Seznam sb√≠rek (Respektuje RBAC)
export async function GET(request: Request) {
  try {
    const session = await getServerSession(authOptions);
    if (!session) {
      return new NextResponse(JSON.stringify({ message: 'Unauthorized' }), { status: 401 });
    }

    const where = session.user.role === 'ADMIN' ? {} : { authorId: session.user.id };

    const collections = await prisma.collection.findMany({
      where,
      orderBy: { createdAt: 'desc' },
      include: { _count: { select: { videos: true } } } 
    });

    return NextResponse.json(collections);
  } catch (error) {
    console.error('API_COLLECTIONS_GET_ERROR', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Error' }), { status: 500 });
  }
}

```

### `app/api/collections/[id]/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { PrismaClient } from '@prisma/client';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';

// D≈ÆLE≈ΩIT√â: Vypnut√≠ cachov√°n√≠ pro tento endpoint
export const dynamic = 'force-dynamic';

const prisma = new PrismaClient();

// Pomocn√° funkce pro kontrolu pr√°v
async function checkPermissions(collectionId: string, session: any) {
  if (!session) {
    return { allowed: false, code: 401, message: 'No session' };
  }

  try {
    const collection = await prisma.collection.findUnique({ 
        where: { id: collectionId } 
    });
  
    if (!collection) {
        return { allowed: false, code: 404, message: 'Collection not found' };
    }

    const isOwner = collection.authorId === session.user.id;
    const isAdmin = session.user.role === 'ADMIN';

    if (!isOwner && !isAdmin) {
        return { allowed: false, code: 403, message: 'Forbidden' };
    }

    return { allowed: true, collection };
  } catch (e) {
      console.error("[checkPermissions] DB Error:", e);
      return { allowed: false, code: 500, message: 'DB Error' };
  }
}

// PUT: Update sb√≠rky (Zmƒõna viditelnosti, n√°zvu)
export async function PUT(request: Request, context: { params: Promise<{ id: string }> }) {
  try {
    const session = await getServerSession(authOptions);
    const params = await context.params;
    const id = params.id;

    const { allowed, code, message } = await checkPermissions(id, session);
    
    if (!allowed) {
       return new NextResponse(JSON.stringify({ message }), { status: code });
    }

    const body = await request.json();
    const { name, description, isPublic } = body;

    const updated = await prisma.collection.update({
      where: { id },
      data: { name, description, isPublic },
    });

    return NextResponse.json(updated);
  } catch (error) {
    console.error('[PUT] Error:', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Error' }), { status: 500 });
  }
}

// DELETE: Smaz√°n√≠ sb√≠rky
export async function DELETE(request: Request, context: { params: Promise<{ id: string }> }) {
  try {
    const session = await getServerSession(authOptions);
    const params = await context.params;
    const id = params.id;

    const { allowed, code, message } = await checkPermissions(id, session);
    if (!allowed) {
        return new NextResponse(JSON.stringify({ message }), { status: code });
    }

    await prisma.collection.delete({ where: { id } });
    return new NextResponse(null, { status: 204 });
  } catch (error) {
    console.error('[DELETE] Error:', error);
    return new NextResponse(JSON.stringify({ message: 'Internal Error' }), { status: 500 });
  }
}

```

### `app/api/youtube/fetch-data/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { Innertube, UniversalCache } from 'youtubei.js';
import he from 'he';

// --- LOGOVAC√ç √öLO≈ΩI≈†Tƒö ---
let debugLogs: string[] = [];
function log(msg: string) {
  const timestamp = new Date().toLocaleTimeString();
  console.log(`[${timestamp}] ${msg}`);
  debugLogs.push(`[${timestamp}] ${msg}`);
}

function extractYouTubeId(url: string): string | null {
  const regex = /(?:https?:\/\/)?(?:www\.)?(?:youtube\.com\/(?:[^\/\n\s]+\/\S+\/|(?:v|e(?:mbed)?)\/|\S*?[?&]v=)|youtu\.be\/)([a-zA-Z0-9_-]{11})/;
  const match = url.match(regex);
  return match ? match[1] : null;
}

// Pomocn√° funkce pro form√°tov√°n√≠ ƒçasu (ms -> MM:SS)
function formatTime(ms: number): string {
    const totalSeconds = Math.floor(ms / 1000);
    const minutes = Math.floor(totalSeconds / 60);
    const seconds = totalSeconds % 60;
    return `[${minutes}:${seconds.toString().padStart(2, '0')}]`;
}

// Pomocn√° funkce pro ruƒçn√≠ sta≈æen√≠ obsahu
async function fetchContent(url: string): Promise<string> {
    const res = await fetch(url, {
        headers: {
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Accept-Language': 'en-US,en;q=0.9',
            'Cookie': 'SOCS=CAI'
        }
    });
    if (!res.ok) throw new Error(`Status ${res.status}`);
    return res.text();
}

// Fallback 1: HTML Scraping (Vylep≈°en√Ω - Googlebot Style)
async function scrapeMetadataFromHtml(videoId: string) {
    try {
        log('Fallback (HTML/Googlebot): Stahuji str√°nku...');
        const url = `https://www.youtube.com/watch?v=${videoId}`;
        
        // Tv√°≈ô√≠me se jako Googlebot - YouTube mu serv√≠ruje statick√° metadata bez JS/Cookies
        const res = await fetch(url, {
            headers: {
                'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)',
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
                'Accept-Language': 'en-US,en;q=0.5'
                // ≈Ω√°dn√© cookies!
            }
        });
        
        if (!res.ok) throw new Error(`HTML fetch status ${res.status}`);
        const html = await res.text();
        
        // Hled√°me standardn√≠ OpenGraph tagy
        const titleMatch = html.match(/<meta property="og:title" content="(.*?)"/);
        const descMatch = html.match(/<meta property="og:description" content="(.*?)"/);
        
        const title = titleMatch ? he.decode(titleMatch[1]) : '';
        const description = descMatch ? he.decode(descMatch[1]) : '';
        
        if (title) log(`HTML Scraping √∫spƒõ≈°n√Ω! Title: "${title.substring(0, 20)}..."`);
        if (description) log(`HTML Description nalezen (${description.length} znak≈Ø).`);
        
        return { title, description };
    } catch (e: any) {
        log(`HTML Scraping selhal: ${e.message}`);
        return { title: '', description: '' };
    }
}

// Fallback 2: oEmbed API (Z√°loha pro Title)
async function fetchOEmbedMetadata(videoId: string) {
    try {
        log('Fallback (oEmbed): Vol√°m ofici√°ln√≠ API...');
        const url = `https://www.youtube.com/oembed?url=https://www.youtube.com/watch?v=${videoId}&format=json`;
        const res = await fetch(url, {
             headers: { 'User-Agent': 'Googlebot/2.1 (+http://www.google.com/bot.html)' }
        });
        
        if (!res.ok) throw new Error(`Status ${res.status}`);
        const json = await res.json();
        
        log(`oEmbed √∫spƒõ≈°n√Ω! Title: "${json.title}"`);
        return { title: json.title || '', description: '' };
    } catch (e: any) {
        log(`oEmbed selhal: ${e.message}`);
        return { title: '', description: '' };
    }
}

// Fallback 3: Invidious API (Posledn√≠ instance)
async function fetchInvidiousMetadata(videoId: string) {
    const instances = [
        'https://inv.tux.pizza',
        'https://vid.puffyan.us',
        'https://invidious.drgns.space'
    ];

    for (const instance of instances) {
        try {
            log(`Fallback (Invidious): Zkou≈°√≠m ${instance}...`);
            // Kr√°tk√Ω timeout, a≈• nezdr≈æujeme
            const controller = new AbortController();
            const timeoutId = setTimeout(() => controller.abort(), 3000);
            
            const res = await fetch(`${instance}/api/v1/videos/${videoId}`, {
                 headers: { 'User-Agent': 'Mozilla/5.0' },
                 signal: controller.signal
            });
            clearTimeout(timeoutId);
            
            if (res.ok) {
                const json = await res.json();
                const title = json.title || '';
                const description = json.description || '';
                log(`Invidious √∫spƒõ≈°n√Ω!`);
                return { title, description };
            }
        } catch (e) {
            log(`Instance ${instance} selhala/timeout.`);
        }
    }
    return { title: '', description: '' };
}

// Pomocn√° funkce pro ruƒçn√≠ sta≈æen√≠ XML titulk≈Ø z baseUrl
async function fetchManualTranscript(baseUrl: string): Promise<string | null> {
    try {
        const res = await fetch(baseUrl, {
            headers: {
                'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            }
        });
        const xml = await res.text();
        
        const regex = /<text[^>]*start="([\d.]+)"[^>]*>([\s\S]*?)<\/text>/g;
        let match;
        const parts = [];
        
        while ((match = regex.exec(xml)) !== null) {
            const startSec = parseFloat(match[1]);
            const content = he.decode(match[2].replace(/<[^>]*>/g, '')); 
            if (content.trim()) {
                const timeStr = formatTime(startSec * 1000);
                parts.push(`${timeStr} ${content}`);
            }
        }
        
        if (parts.length > 0) {
            return parts.join('\n');
        }
        
    } catch (e) {
        console.error('Manual fetch error:', e);
    }
    return null;
}

export async function GET(request: Request) {
  debugLogs = [];
  
  try {
    // 1. Auth
    const session = await getServerSession(authOptions);
    if (!session || session.user?.role !== 'ADMIN') {
      return NextResponse.json({ message: 'Unauthorized' }, { status: 401 });
    }

    // 2. URL
    const { searchParams } = new URL(request.url);
    const url = searchParams.get('url');
    log(`Start request for URL: ${url}`);

    if (!url) return NextResponse.json({ message: 'Missing URL' }, { status: 400 });

    const videoId = extractYouTubeId(url);
    log(`Extracted Video ID: ${videoId}`);
    
    if (!videoId) return NextResponse.json({ message: 'Invalid ID' }, { status: 400 });

    // 3. Inicializace InnerTube
    log('Inicializuji youtubei.js (InnerTube)...');
    const yt = await Innertube.create({
        cache: new UniversalCache(false),
        generate_session_locally: true,
        lang: 'en',
        location: 'US' 
    });

    log('Z√≠sk√°v√°m Info o videu (GetInfo)...');
    const info = await yt.getInfo(videoId);
    
    // --- Z√çSK√ÅN√ç METADAT (V√≠cevrstv√° strategie) ---
    let title = info.basic_info.title || '';
    let description = info.basic_info.short_description || '';

    // Stupe≈à 2: RAW data z API
    if (!title) {
        log('Basic info pr√°zdn√©. Zkou≈°√≠m RAW...');
        try {
            // @ts-ignore
            const videoDetails = info.player_response?.videoDetails;
            if (videoDetails) {
                title = videoDetails.title || '';
                description = videoDetails.shortDescription || '';
                log(`RAW metadata OK.`);
            }
        } catch (e) {}
    }

    // Stupe≈à 3: HTML Scraping (Googlebot - nejlep≈°√≠ pro Description)
    if (!title || !description) {
        const htmlData = await scrapeMetadataFromHtml(videoId);
        if (!title && htmlData.title) title = htmlData.title;
        if (!description && htmlData.description) description = htmlData.description;
    }

    // Stupe≈à 4: Invidious API (Kdyby Googlebot selhal)
    if (!description) {
        log('Popis st√°le chyb√≠. Vol√°m Invidious API...');
        const invData = await fetchInvidiousMetadata(videoId);
        if (invData.description) description = invData.description;
        if (!title && invData.title) title = invData.title;
    }

    // Stupe≈à 5: oEmbed (Posledn√≠ z√°chrana pro Title)
    if (!title) {
        const oembedData = await fetchOEmbedMetadata(videoId);
        if (oembedData.title) title = oembedData.title;
    }
    // -------------------------------------------

    log(`Fin√°ln√≠ Metadata - Title: "${title.substring(0, 20)}..."`);
    if (description) log(`Popis z√≠sk√°n (${description.length} znak≈Ø).`);
    else log(`! Popis se nepoda≈ôilo z√≠skat.`);

    // 4. Z√≠sk√°n√≠ p≈ôepisu (Transcript)
    let transcript = '';
    let warning = null;

    try {
        log('Pokus 1: info.getTranscript()...');
        const transcriptData = await info.getTranscript();
        
        if (transcriptData?.transcript?.content?.body?.initial_segments) {
            const segments = transcriptData.transcript.content.body.initial_segments;
            log(`√öspƒõch! Nalezeno ${segments.length} segment≈Ø.`);
            
            transcript = segments.map((seg: any) => {
                const text = seg.snippet?.text || '';
                const startMs = parseInt(seg.start_ms || '0', 10);
                const timeStr = formatTime(startMs);
                return `${timeStr} ${text}`;
            }).join('\n');

            log(`P≈ôepis zform√°tov√°n (s ƒçasov√Ωmi znaƒçkami).`);
        }
    } catch (e: any) {
        log(`Pokus 1 selhal: ${e.message}.`);
        
        // Fallback pro p≈ôepis (XML)
        log('Pokus 2: Hled√°m caption_tracks (Fallback)...');
        const captions = (info as any).captions?.caption_tracks;
        
        if (captions && Array.isArray(captions) && captions.length > 0) {
            const manualTrack = captions.find((t: any) => t.kind !== 'asr');
            const targetTrack = manualTrack || captions[0];
            
            if (targetTrack.base_url) {
                log('Stahuji XML z base_url...');
                const manualText = await fetchManualTranscript(targetTrack.base_url);
                if (manualText && manualText.length > 0) {
                    transcript = manualText;
                    log(`√öspƒõch (Fallback XML).`);
                    warning = `Pou≈æit fallback re≈æim (XML).`;
                }
            }
        }
    }

    if (!transcript) {
        if (!warning) warning = 'Titulky se nepoda≈ôilo z√≠skat.';
        log('V≈°echny pokusy selhaly.');
    }

    return NextResponse.json({
      title,
      description,
      transcript,
      warning,
      debugLogs 
    });

  } catch (error: any) {
    log(`CRITICAL ERROR: ${error.message}`);
    return NextResponse.json({ 
        message: 'Internal Server Error', 
        error: error.message,
        debugLogs 
    }, { status: 500 });
  }
}
```

### `app/api/ai/generate/route.ts`

```typescript
import { NextResponse } from 'next/server';
import { getServerSession } from 'next-auth/next';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { GoogleGenerativeAI } from '@google/generative-ai';

export async function POST(request: Request) {
  try {
    // 1. Diagnostika API Kl√≠ƒçe
    const apiKey = process.env.GEMINI_API_KEY;
    if (!apiKey) {
      console.error('CRITICAL: GEMINI_API_KEY is missing');
      return NextResponse.json({ message: 'Server Error: API Key not configured' }, { status: 500 });
    }

    // 2. Bezpeƒçnostn√≠ kontrola
    const session = await getServerSession(authOptions);
    if (!session || session.user?.role !== 'ADMIN') {
      return NextResponse.json({ message: 'Unauthorized' }, { status: 403 });
    }

    // 3. Z√≠sk√°n√≠ dat
    const body = await request.json();
    const { transcript } = body;

    if (!transcript || typeof transcript !== 'string') {
      return NextResponse.json({ message: 'Chyb√≠ p≈ôepis videa (transcript).' }, { status: 400 });
    }

    // 4. P≈ô√≠prava Promptu
    const systemPrompt = `
Pros√≠m z p≈ôilo≈æen√©ho p≈ôepisu videa v p≈ô√≠loze vytvo≈ô jednoduch√Ω jedno√∫rov≈àov√Ω strukturovan√Ω obsah tohoto videa, kde ka≈æd√° odr√°≈æka bude ƒç√≠slov√°na sv√Ωm po≈ôad√≠m ve form√°tu "X."
    `.trim();

    const fullPrompt = `${systemPrompt}\n\n--- P≈òEPIS VIDEA ---\n${transcript}`;

    // 5. Inicializace a vol√°n√≠ AI
    const genAI = new GoogleGenerativeAI(apiKey);
    
    // POU≈Ω√çV√ÅME MODEL Z VA≈†EHO SEZNAMU (gemini-2.0-flash)
    const model = genAI.getGenerativeModel({ model: 'gemini-2.0-flash' });

    console.log('ü§ñ Generuji obsah pomoc√≠ modelu gemini-2.0-flash...');
    
    const result = await model.generateContent(fullPrompt);
    const response = await result.response;
    const text = response.text();

    console.log('‚úÖ AI obsah √∫spƒõ≈°nƒõ vygenerov√°n.');

    // 6. N√°vrat v√Ωsledku
    return NextResponse.json({ 
      content: text,
      message: 'Obsah √∫spƒõ≈°nƒõ vygenerov√°n.' 
    });

  } catch (error: any) {
    console.error('AI_GENERATE_ERROR', error);
    return NextResponse.json({ 
      message: 'Chyba p≈ôi komunikaci s AI: ' + (error.message || 'Unknown error') 
    }, { status: 500 });
  }
}
```

### `lib/parser.ts`

```typescript
// Definujeme typ pro n√°vratovou hodnotu
export interface ParsedChapter {
  text: string;
  startTime: number;
  endTime: number | null;
  level: number;
}

/**
 * P≈ôevede ƒçasov√Ω ≈ôetƒõzec (MM:SS) na sekundy.
 */
function timeToSeconds(timeStr: string): number {
  const parts = timeStr.split(':').map(Number);
  if (parts.length === 2) {
    return parts[0] * 60 + parts[1];
  }
  // TODO: Zv√°≈æit o≈°et≈ôen√≠ neplatn√©ho form√°tu, i kdy≈æ Regex by to mƒõl chytit
  return 0;
}

/**
 * Parsov√°n√≠ strukturovan√©ho obsahu z form√°tu MTF-H [cite: 185]
 */
export function parseStructuredContent(
  rawText: string
): Omit<ParsedChapter, 'order'>[] {
  const lines = rawText.split('\n').filter((line) => line.trim() !== ''); // Ignoruj pr√°zdn√© ≈ô√°dky [cite: 218]
  const chapters: Omit<ParsedChapter, 'order'>[] = [];

  for (const line of lines) {
    const trimmedLine = line.trim();

    // 1. Extrakce ƒçasov√© znaƒçky na konci [cite: 201]
    const timeRegex = /\((\d{1,2}:\d{2})(?:\s*-\s*(\d{1,2}:\d{2}))?\)$/;
    const timeMatch = trimmedLine.match(timeRegex);

    if (!timeMatch) {
      throw new Error(
        `Neplatn√Ω form√°t ≈ô√°dku: Chyb√≠ ƒçasov√° znaƒçka (MM:SS) na konci. ≈ò√°dek: "${trimmedLine}"`
      ); // 
    }

    const startTime = timeToSeconds(timeMatch[1]);
    const endTime = timeMatch[2] ? timeToSeconds(timeMatch[2]) : null;

    // 2. Extrakce z√°kladu (v≈°e p≈ôed ƒçasem) [cite: 202]
    const baseText = trimmedLine.substring(0, timeMatch.index).trim();

    // 3. Extrakce ƒç√≠slov√°n√≠ a v√Ωpoƒçet √∫rovnƒõ [cite: 203]
    const numberingRegex = /^(\d+(?:\.\d+)*)\.?\s+/;
    const numberingMatch = baseText.match(numberingRegex);

    if (!numberingMatch) {
      throw new Error(
        `Neplatn√Ω form√°t ≈ô√°dku: Chyb√≠ hierarchick√© ƒç√≠slov√°n√≠ (nap≈ô. 1.1.) na zaƒç√°tku. ≈ò√°dek: "${trimmedLine}"`
      ); // 
    }

    // 4. V√Ωpoƒçet √∫rovnƒõ [cite: 204]
    // "1." -> level 0
    // "1.1." -> level 1
    // "1.1.1." -> level 2
    const level = numberingMatch[1].split('.').length - 1;

    // 5. Ulo≈æen√≠ textu (ZMƒöNA: Ukl√°d√°me cel√Ω p≈Øvodn√≠ ≈ô√°dek) [cite: 205]
    const text = trimmedLine; // Cel√Ω ≈ô√°dek vƒçetnƒõ ƒçasov√© znaƒçky

    chapters.push({ text, startTime, endTime, level });
  }

  return chapters;
}
```

### `app/video/[id]/page.tsx`

```typescript
import { PrismaClient } from '@prisma/client';
import { notFound } from 'next/navigation';
// 1. IMPORT WRAPPERU
import VideoDetailClientWrapper from '@/components/VideoDetailClientWrapper';
import { authOptions } from '@/app/api/auth/[...nextauth]/route';
import { getServerSession } from 'next-auth';

const prisma = new PrismaClient();

interface VideoDetailPageProps {
  params: Promise<{
    id: string;
  }>;
}

export const dynamic = 'force-dynamic';

export default async function VideoDetailPage({ params }: VideoDetailPageProps) {
  // Await params (Next.js 15+)
  const { id } = await params;

  // 1. Naƒçten√≠ session a kontrola admin role
  const session = await getServerSession(authOptions);
  const isAdmin = session?.user?.role === 'ADMIN';

  // 2. Naƒçten√≠ videa vƒçetnƒõ kolekc√≠ (pro kontrolu ve≈ôejnosti)
  const video = await prisma.video.findUnique({
    where: { id: id },
    include: {
      chapters: {
        orderBy: {
          order: 'asc', // Se≈ôad√≠me kapitoly dle 'order'
        },
      },
      // P≈òID√ÅNO: Naƒçten√≠ kolekc√≠ pro kontrolu ve≈ôejnosti
      collections: {
        select: {
          isPublic: true
        }
      }
    },
  });

  if (!video) {
    notFound();
  }

  // 3. Kontrola, zda je video ve ve≈ôejn√© sb√≠rce
  const isPublic = video.collections.some(col => col.isPublic);

  // 4. Fin√°ln√≠ bezpeƒçnostn√≠ kontrola
  if (!isPublic && !isAdmin) {
    notFound();
  }

  return (
    // ZMƒöNA: Zvƒõt≈°ena ≈°√≠≈ôka str√°nky na max-w-7xl/max-w-screen-2xl/max-w-[1366px] pro nov√Ω layout
    <main className="max-w-[1366px] mx-auto p-4 sm:p-6 lg:p-8">
      {/* N√°zev Videa (z≈Øst√°v√° naho≈ôe) */}
      <h1 className="text-3xl font-bold mb-5">{video.title}</h1>

      {/* 3. POU≈ΩIT√ç KLIENTSK√âHO WRAPPERU */}
      {/* ZMƒöNA: P≈ôed√°v√°me nyn√≠ i 'summary' dovnit≈ô wrapperu */}
      <VideoDetailClientWrapper
        youtubeId={video.youtubeId}
        chapters={video.chapters}
        summary={video.summary}
      />

      {/* ZMƒöNA: P≈Øvodn√≠ <div className="mt-8"> se shrnut√≠m
          byl odsud odstranƒõn a p≈ôesunut dovnit≈ô
          VideoDetailClientWrapperu, aby mohl b√Ωt souƒç√°st√≠ layoutu.
      */}
    </main>
  );
}
```

